# Тема “Обучение без учителя”
# Задание 1
# Импортируйте библиотеки pandas, numpy и matplotlib.
# Загрузите "Boston House Prices dataset" из встроенных наборов данных библиотеки sklearn.
# Создайте датафреймы X и y из этих данных.
# Разбейте эти датафреймы на тренировочные (X_train, y_train) и тестовые (X_test, y_test)
# с помощью функции train_test_split так, чтобы размер тестовой выборки
# составлял 20% от всех данных, при этом аргумент random_state должен быть равен 42.
# Масштабируйте данные с помощью StandardScaler.
# Постройте модель TSNE на тренировочный данных с параметрами:
# n_components=2, learning_rate=250, random_state=42.
# Постройте диаграмму рассеяния на этих данных.

import pandas as pd
import numpy as np
import warnings
warnings.filterwarnings('ignore')
import matplotlib.pyplot as plt
plt.style.use('fivethirtyeight')
from sklearn.model_selection import train_test_split
from sklearn.manifold import TSNE
from sklearn.cluster import KMeans
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

%config InlineBackend.figure_format = 'svg'
%matplotlib inline


from sklearn.datasets import load_boston


boston = load_boston()

data = boston.data

feature_names = boston.feature_names

X = pd.DataFrame(data, columns = feature_names)

X.head()

X.info()

price = boston.target

X_train, X_test, y_train, y_test = train_test_split(X, price, test_size = 0.2, random_state = 42)

from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()

X_train_scaled = scaler.fit_transform(X_train)

X_test_scaled = scaler.fit_transform(X_test)

X_train_scaled = pd.DataFrame(X_train_scaled, columns = feature_names)

X_test_scaled = pd.DataFrame(X_test_scaled, columns = feature_names)

tsne = TSNE(n_components = 2, learning_rate = 250, random_state = 42)

X_train_tsne = tsne.fit_transform(X_train_scaled)

plt.scatter(X_train_tsne[:, 0], X_train_tsne[:, 1])

# Задание 2
# С помощью KMeans разбейте данные из тренировочного набора на 3 кластера,
# используйте все признаки из датафрейма X_train.
# Параметр max_iter должен быть равен 100, random_state сделайте равным 42.
# Постройте еще раз диаграмму рассеяния на данных, полученных с помощью TSNE,
# и раскрасьте точки из разных кластеров разными цветами.
# Вычислите средние значения price и CRIM в разных кластерах.

kmeans = KMeans(n_clusters = 3)

labels_train = kmeans.fit_predict(X_train_scaled)

labels_test = kmeans.predict(X_test_scaled)

plt.scatter(X_train_tsne[:, 0], X_train_tsne[:, 1], c = labels_train, alpha=0.2)

y_train.mean()

y_train[labels_train == 0].mean()

y_train[labels_train == 1].mean()

y_train[labels_train == 2].mean()

X_train.loc[labels_train == 0, 'CRIM'].mean()

X_train.loc[labels_train == 1, 'CRIM'].mean()

labels_train

X_train.loc[labels_train == 2, 'CRIM'].mean()

# plt.hist(X_train.loc[labels_train == 0, 'CRIM'], bins = 20, density = True, alpha = 0.5)
# plt.hist(X_train.loc[labels_train == 1, 'CRIM'], bins = 20, density = True, alpha = 0.5)
# plt.hist(X_train.loc[labels_train == 2, 'CRIM'], bins = 20, density = True, alpha = 0.5)
# plt.xlim(0, 2)

# Задание 3
# Примените модель KMeans, построенную в предыдущем задании,
# к данным из тестового набора.
# Вычислите средние значения price и CRIM в разных кластерах на тестовых данных.

lr = LinearRegression()

lr.fit(X_train_scaled, y_train)

LinearRegression(copy_X=True, fit_intercept=True, n_jobs=None, normalize=False)

y_test_pred = lr.predict(X_test_scaled)

r2_score(y_test, y_test_pred)

#Модель для нулевого кластера
lr.fit(X_train_scaled.loc[labels_train == 0, :],
       y_train[labels_train == 0])
y_test_pred_0 = lr.predict(X_test_scaled.loc[labels_test == 0, :])
r2_score(y_test[labels_test == 0], y_test_pred_0)

#Модель для первого кластера
lr.fit(X_train_scaled.loc[labels_train == 1, :],
       y_train[labels_train == 1])
y_test_pred_1 = lr.predict(X_test_scaled.loc[labels_test == 1, :])
r2_score(y_test[labels_test == 1], y_test_pred_1)

#Модель для второго кластера
lr.fit(X_train_scaled.loc[labels_train == 2, :],
       y_train[labels_train == 2])
y_test_pred_2 = lr.predict(X_test_scaled.loc[labels_test == 2, :])
r2_score(y_test[labels_test == 2], y_test_pred_2)

X_test.loc[labels_test == 0, 'CRIM'].mean()

X_test.loc[labels_test == 1, 'CRIM'].mean()

X_test.loc[labels_test == 2, 'CRIM'].mean()

y_test[labels_test == 0].mean()

y_test[labels_test == 1].mean()

y_test[labels_test == 2].mean()
